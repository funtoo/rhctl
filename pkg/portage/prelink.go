/*
Copyright Â© 2021-2022 Macaroni OS Linux
See AUTHORS and LICENSE for the license details and contributors.
*/
package portage

import (
	"fmt"
	"os"
	"strings"

	"github.com/macaroni-os/macaronictl/pkg/utils"
)

const (
	prelinkConfHeader = `# prelink.conf autogenerated by macaronictl env-update; make all changes to
# contents of /etc/env.d directory
`
)

func writePrelinkFile(file string, prelinkPaths, prelinkMaskPaths []string, opts *EnvUpdateOpts) error {
	var f *os.File
	var err error

	potentialLibDirs := []string{
		"/lib", "/lib64",
		"/usr/lib", "/usr/lib64",
		"/bin", "/sbin",
	}

	if opts.DryRun {
		f = os.Stdout
	} else {
		f, err = os.OpenFile(file, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0644)
		if err != nil {
			return err
		}
		defer f.Close()
	}

	// Write file header
	_, err = f.WriteString(prelinkConfHeader + "\n")
	if err != nil {
		return err
	}

	for _, d := range potentialLibDirs {
		if utils.Exists(d) {
			_, err := f.WriteString(fmt.Sprintf("-l %s", d) + "\n")
			if err != nil {
				return err
			}
		}
	}

	for _, d := range prelinkPaths {
		_, err := f.WriteString(fmt.Sprintf("-h %s", d) + "\n")
		if err != nil {
			return err
		}
	}

	for _, d := range prelinkMaskPaths {
		_, err := f.WriteString(fmt.Sprintf("-b %s", d) + "\n")
		if err != nil {
			return err
		}
	}

	return nil
}

func preparePrelinkPaths(envsRef *map[string]string, opts *EnvUpdateOpts) ([]string, []string) {
	m := *envsRef
	prelinkPaths := []string{}
	prelinkMaskPaths := []string{}

	stagingPaths := []string{}

	if val, ok := m["LDPATH"]; ok {
		if val != "" {
			stagingPaths = append(stagingPaths, strings.Split(val, ":")...)
		}
	}

	if val, ok := m["PATH"]; ok {
		if val != "" {
			stagingPaths = append(stagingPaths, strings.Split(val, ":")...)
		}
	}

	if val, ok := m["PRELINK_PATH"]; ok {
		if val != "" {
			stagingPaths = append(stagingPaths, strings.Split(val, ":")...)
		}
	}

	if val, ok := m["PRELINK_PATH_MASK"]; ok {
		if val != "" {
			prelinkMaskPaths = append(prelinkMaskPaths, strings.Split(val, ":")...)
		}
	}

	for _, p := range stagingPaths {

		if p[len(p)-1:] != "/" {
			p += "/"
		}
		plmasked := false
		for _, pm := range prelinkMaskPaths {
			if pm[len(pm)-1:] != "/" {
				pm += "/"
			}
			if len(pm) > len(p) {
				continue
			}
			if pm == p[0:len(pm)] {
				plmasked = true
				break
			}
		}

		if !plmasked {
			prelinkPaths = append(prelinkPaths, p)
		}
	}

	return prelinkPaths, prelinkMaskPaths
}
